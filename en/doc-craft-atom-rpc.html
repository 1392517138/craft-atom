<!DOCTYPE html>
<html>
	<head>
		<meta charset='utf-8'>
	  	<meta http-equiv="X-UA-Compatible" content="chrome=1">
	  	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
	  	<link rel="icon" href="../favicon.ico" type="image/x-icon">
	  	<link rel="stylesheet" href="../css/craft.css">
	  	<link rel="stylesheet" href="../css/code.css">
		<script type="text/javascript" src="../js/jquery.js"></script>
		<script type="text/javascript" src="../js/craft.js"></script>
		<script type="text/javascript" src="../js/rainbow.js"></script>
		<script type="text/javascript" src="../js/rainbow.generic.js"></script>
		<script type="text/javascript" src="../js/rainbow.java.js"></script>
		<title>Documentation: craft-atom-rpc</title>
	</head>

	<body>
		<div id="header" class="header"></div>
		
		<div id="center" class="center">
			<div id="content" class="content">
<h1>craft-atom-rpc</h1>
<div class="date">Oct 9, 2014 by mindwind</div>

<h2>Introduction</h2>
<p>
An easy use and efficient java rpc component.<br>
It provides:<br>
- Synchronous invocation.<br>
- Asynchronous invocation.
</p>

<h2>Getting Started</h2>
<p>
Using rpc include two steps:<br>
1. Export remote API for server side.<br>
2. Import remote API and invoke it for client side.
</p>

<h3>Export remote API</h3>
<p>Only exported API can be invoked from remote peer, the code example as follows:</p>
<pre><code data-language="java">
RpcServer server = RpcFactory.newRpcServer(port);
server.export(DemoService.class, new DemoServiceImpl(), new RpcParameter(10, 100));
server.open();
</code></pre>

<p>Not export entire interface just a method.</p>
<pre><code data-language="java">
RpcMethod rpcMethod = new RpcMethod();
rpcMethod.setName("echo");
rpcMethod.setParameterTypes(new Class&lt;?&gt;[] { String.class });
server.export(DemoService.class, rpcMethod, new DemoServiceImpl1(), new RpcParameter(10, 100));
</code></pre>

<p>For polymorphism of OOP, if a interface has more than one implementor, how to export?</p>
<pre><code data-language="java">
// Set 'rpcId' to bind a specific interface implementor
String rpcId = "demo2";
server.export(rpcId, DemoService.class, new DemoServiceImpl2(), new RpcParameter());
</code></pre>

<h3>Import remote API</h3>
<pre><code data-language="java">
client = RpcFactory.newRpcClient(host, port);
client.open();
DemoService demo = client.refer(DemoService.class);
demo.echo("hi");
</code></pre>

<h3>Polymorphic invocation</h3>
<p><code>DemoService</code> has another implementor and exported with 'demo2' as its rpc id.
<pre><code data-language="java">
// Invoke another implementor which rpcId is 'demo2'
DemoService demo = client.refer(DemoService.class);
RpcContext.getContext().setRpcId("demo2");
demo.echo("hi");
</code></pre>

<h3>Asynchronous invocation</h3>
<p>The default remote invocation is synchronous, launch asynchronous invocation code example as follows:</p>
<pre><code data-language="java">
// Set invocation of this time is asynchronous
RpcContext ctx = RpcContext.getContext();
ctx.setAsync(true);
String r = ds.echo("hi");

// Return null for asynchronous invocation.
assert r == null;

// Do something other ... and get the invocation result.
Future&lt;String&gt; future = ctx.getFuture();
r = future.get(2, TimeUnit.SECONDS);
assert r != null;
</code></pre>

<h3>Oneway invocation</h3>
<p>
Oneway is a special asynchronous invocation, which means the client does not expect the server response for this invocation.
Actually server also never response oneway request. The code example as follows:
</p>
<pre><code data-language="java">
/ Set invocation of this time is oneway
RpcContext ctx = RpcContext.getContext();
ctx.setOneway(true);
String r = ds.echo("hi");

// Return null for oneway invocation.
assert r == null;

// Oneway invocation, no future object return.
Future&lt;String&gt; future = ctx.getFuture();
assert future == null;
</code></pre>

			</div>
		</div>
		
		<div id="footer" class="footer"></div>
	</body>
</html>